// Generated by ReScript, PLEASE EDIT WITH CARE


let AudioWorklet = {};

let $$Float32Array = {};

function dbToLinear(db) {
  return Math.pow(10.0, db / 20.0);
}

function linearToDb(linear) {
  if (linear <= 0.0) {
    return -120.0;
  } else {
    return 20.0 * Math.log10(linear);
  }
}

function clamp(value, minVal, maxVal) {
  return Math.max(minVal, Math.min(maxVal, value));
}

function smoothCoefficient(timeMs, sampleRate) {
  if (timeMs <= 0.0) {
    return 1.0;
  }
  let samples = timeMs * sampleRate / 1000.0;
  return 1.0 - Math.exp(-1.0 / samples);
}

let DSP = {
  dbToLinear: dbToLinear,
  linearToDb: linearToDb,
  clamp: clamp,
  smoothCoefficient: smoothCoefficient
};

function make(attackMs, releaseMs, sampleRate) {
  return {
    envelope: 0.0,
    attackCoef: smoothCoefficient(attackMs, sampleRate),
    releaseCoef: smoothCoefficient(releaseMs, sampleRate)
  };
}

function process(ef, input) {
  let absInput = Math.abs(input);
  if (absInput > ef.envelope) {
    ef.envelope = ef.envelope + ef.attackCoef * (absInput - ef.envelope);
  } else {
    ef.envelope = ef.envelope + ef.releaseCoef * (absInput - ef.envelope);
  }
  return ef.envelope;
}

let EnvelopeFollower = {
  make: make,
  process: process
};

function make$1() {
  return {
    b0: 1.0,
    b1: 0.0,
    b2: 0.0,
    a1: 0.0,
    a2: 0.0,
    x1: 0.0,
    x2: 0.0,
    y1: 0.0,
    y2: 0.0
  };
}

function configure(f, filterType, freq, sampleRate, q, gainDb) {
  let w0 = 2.0 * Math.PI * freq / sampleRate;
  let cosW0 = Math.cos(w0);
  let sinW0 = Math.sin(w0);
  let alpha = sinW0 / (2.0 * q);
  let a = dbToLinear(gainDb / 2.0);
  let match;
  switch (filterType) {
    case "LowPass" :
      match = [
        (1.0 - cosW0) / 2.0,
        1.0 - cosW0,
        (1.0 - cosW0) / 2.0,
        1.0 + alpha,
        -2.0 * cosW0,
        1.0 - alpha
      ];
      break;
    case "HighPass" :
      match = [
        (1.0 + cosW0) / 2.0,
        - (1.0 + cosW0),
        (1.0 + cosW0) / 2.0,
        1.0 + alpha,
        -2.0 * cosW0,
        1.0 - alpha
      ];
      break;
    case "Peak" :
      match = [
        1.0 + alpha * a,
        -2.0 * cosW0,
        1.0 - alpha * a,
        1.0 + alpha / a,
        -2.0 * cosW0,
        1.0 - alpha / a
      ];
      break;
    default:
      match = [
        1.0,
        0.0,
        0.0,
        1.0,
        0.0,
        0.0
      ];
  }
  let a0 = match[3];
  f.b0 = match[0] / a0;
  f.b1 = match[1] / a0;
  f.b2 = match[2] / a0;
  f.a1 = match[4] / a0;
  f.a2 = match[5] / a0;
}

function process$1(f, input) {
  let output = f.b0 * input + f.b1 * f.x1 + f.b2 * f.x2 - f.a1 * f.y1 - f.a2 * f.y2;
  f.x2 = f.x1;
  f.x1 = input;
  f.y2 = f.y1;
  f.y1 = output;
  return output;
}

let BiquadFilter = {
  make: make$1,
  configure: configure,
  process: process$1
};

function make$2(sampleRate) {
  return {
    enabled: true,
    targetLufs: -14.0,
    maxGainDb: 12.0,
    minGainDb: -24.0,
    currentGain: 1.0,
    integratedSum: 0.0,
    sampleCount: 0,
    gainSmooth: smoothCoefficient(100.0, sampleRate)
  };
}

function process$2(n, samples) {
  if (!n.enabled) {
    return;
  }
  let len = samples.length;
  let sumSquares = 0.0;
  for (let i = 0; i < len; ++i) {
    let sample = samples[i];
    sumSquares = sumSquares + sample * sample;
  }
  let meanSquares = sumSquares / len;
  if (meanSquares > 0.0) {
    linearToDb(Math.sqrt(meanSquares));
  }
  n.integratedSum = n.integratedSum + sumSquares;
  n.sampleCount = n.sampleCount + len | 0;
  let integratedDb;
  if (n.sampleCount > 0) {
    let mean = n.integratedSum / n.sampleCount;
    integratedDb = mean > 0.0 ? linearToDb(Math.sqrt(mean)) : -120.0;
  } else {
    integratedDb = -120.0;
  }
  let gainDb = clamp(n.targetLufs - integratedDb, n.minGainDb, n.maxGainDb);
  let targetGain = dbToLinear(gainDb);
  n.currentGain = n.currentGain + n.gainSmooth * (targetGain - n.currentGain);
  for (let i$1 = 0; i$1 < len; ++i$1) {
    let sample$1 = samples[i$1];
    samples[i$1] = sample$1 * n.currentGain;
  }
}

let Normalizer = {
  make: make$2,
  process: process$2
};

function make$3(sampleRate) {
  return {
    enabled: true,
    thresholdDb: -18.0,
    ratio: 4.0,
    kneeDb: 4.0,
    makeupGainDb: 4.0,
    envelope: 0.0,
    attackCoef: smoothCoefficient(10.0, sampleRate),
    releaseCoef: smoothCoefficient(150.0, sampleRate)
  };
}

function computeGain(c, inputDb) {
  if (inputDb < c.thresholdDb - c.kneeDb / 2.0) {
    return 0.0;
  }
  if (inputDb > c.thresholdDb + c.kneeDb / 2.0) {
    return c.thresholdDb + (inputDb - c.thresholdDb) / c.ratio - inputDb;
  }
  let kneeStart = c.thresholdDb - c.kneeDb / 2.0;
  let x = inputDb - kneeStart;
  return (1.0 / c.ratio - 1.0) * x * x / (2.0 * c.kneeDb);
}

function process$3(c, samples) {
  if (!c.enabled) {
    return;
  }
  let len = samples.length;
  let makeupLinear = dbToLinear(c.makeupGainDb);
  for (let i = 0; i < len; ++i) {
    let sample = samples[i];
    let inputDb = linearToDb(Math.abs(sample));
    if (inputDb > c.envelope) {
      c.envelope = c.envelope + c.attackCoef * (inputDb - c.envelope);
    } else {
      c.envelope = c.envelope + c.releaseCoef * (inputDb - c.envelope);
    }
    let grDb = computeGain(c, c.envelope);
    let gain = dbToLinear(grDb) * makeupLinear;
    samples[i] = sample * gain;
  }
}

let Compressor = {
  make: make$3,
  computeGain: computeGain,
  process: process$3
};

function make$4(sampleRate) {
  return {
    enabled: true,
    ceilingDb: -0.5,
    envelope: 1.0,
    releaseCoef: smoothCoefficient(50.0, sampleRate)
  };
}

function process$4(l, samples) {
  if (!l.enabled) {
    return;
  }
  let len = samples.length;
  let ceilingLinear = dbToLinear(l.ceilingDb);
  for (let i = 0; i < len; ++i) {
    let sample = samples[i];
    let peak = Math.abs(sample);
    if (peak > ceilingLinear) {
      let targetAtten = ceilingLinear / peak;
      if (targetAtten < l.envelope) {
        l.envelope = targetAtten;
      } else {
        l.envelope = l.envelope + l.releaseCoef * (1.0 - l.envelope);
      }
    } else {
      l.envelope = l.envelope + l.releaseCoef * (1.0 - l.envelope);
    }
    samples[i] = sample * l.envelope;
  }
}

let Limiter = {
  make: make$4,
  process: process$4
};

function make$5(sampleRate) {
  return {
    bypass: false,
    normalizer: make$2(sampleRate),
    compressor: make$3(sampleRate),
    limiter: make$4(sampleRate),
    inputLevel: -120.0,
    outputLevel: -120.0
  };
}

function process$5(p, samples) {
  if (p.bypass) {
    return;
  }
  let len = samples.length;
  let inputSum = 0.0;
  for (let i = 0; i < len; ++i) {
    let s = samples[i];
    inputSum = inputSum + s * s;
  }
  p.inputLevel = linearToDb(Math.sqrt(inputSum / len));
  process$2(p.normalizer, samples);
  process$3(p.compressor, samples);
  process$4(p.limiter, samples);
  let outputSum = 0.0;
  for (let i$1 = 0; i$1 < len; ++i$1) {
    let s$1 = samples[i$1];
    outputSum = outputSum + s$1 * s$1;
  }
  p.outputLevel = linearToDb(Math.sqrt(outputSum / len));
}

function setBypass(p, bypass) {
  p.bypass = bypass;
}

function setTargetLoudness(p, lufs) {
  p.normalizer.targetLufs = lufs;
}

let VoluModProcessor = {
  make: make$5,
  process: process$5,
  setBypass: setBypass,
  setTargetLoudness: setTargetLoudness
};

export {
  AudioWorklet,
  $$Float32Array,
  DSP,
  EnvelopeFollower,
  BiquadFilter,
  Normalizer,
  Compressor,
  Limiter,
  VoluModProcessor,
}
/* No side effect */
