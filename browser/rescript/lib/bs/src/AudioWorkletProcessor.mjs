// Generated by ReScript, PLEASE EDIT WITH CARE


let AudioWorkletProcessor = {};

let MessagePort = {};

function makeState(sampleRate) {
  let smoothCoef = timeMs => {
    if (timeMs <= 0.0) {
      return 1.0;
    } else {
      return 1.0 - Math.exp(-1.0 / (timeMs * sampleRate / 1000.0));
    }
  };
  return {
    bypass: false,
    targetLufs: -14.0,
    compressionRatio: 4.0,
    noiseReduction: true,
    normGain: 1.0,
    normIntegrated: 0.0,
    normSamples: 0,
    compEnvelope: -120.0,
    limEnvelope: 1.0,
    normSmooth: smoothCoef(100.0),
    compAttack: smoothCoef(10.0),
    compRelease: smoothCoef(150.0),
    limRelease: smoothCoef(50.0)
  };
}

function dbToLinear(db) {
  return Math.pow(10.0, db / 20.0);
}

function linearToDb(linear) {
  if (linear <= 0.0) {
    return -120.0;
  } else {
    return 20.0 * Math.log10(linear);
  }
}

function clamp(v, lo, hi) {
  return Math.max(lo, Math.min(hi, v));
}

function processChannel(state, input, output) {
  if (state.bypass) {
    input.forEach((sample, i) => {
      output[i] = sample;
    });
    return;
  }
  let len = input.length;
  let inputSum = {
    contents: 0.0
  };
  input.forEach(sample => {
    inputSum.contents = inputSum.contents + sample * sample;
  });
  let inputRms = Math.sqrt(inputSum.contents / len);
  linearToDb(inputRms);
  state.normIntegrated = state.normIntegrated + inputSum.contents;
  state.normSamples = state.normSamples + len | 0;
  let integratedDb;
  if (state.normSamples > 0) {
    let mean = state.normIntegrated / state.normSamples;
    integratedDb = linearToDb(Math.sqrt(mean));
  } else {
    integratedDb = -120.0;
  }
  let gainDb = clamp(state.targetLufs - integratedDb, -24.0, 12.0);
  let targetGain = dbToLinear(gainDb);
  state.normGain = state.normGain + state.normSmooth * (targetGain - state.normGain);
  input.forEach((sample, i) => {
    let normalized = sample * state.normGain;
    let sampleDb = linearToDb(Math.abs(normalized));
    if (sampleDb > state.compEnvelope) {
      state.compEnvelope = state.compEnvelope + state.compAttack * (sampleDb - state.compEnvelope);
    } else {
      state.compEnvelope = state.compEnvelope + state.compRelease * (sampleDb - state.compEnvelope);
    }
    let compGainDb;
    if (state.compEnvelope < -18.0 - 4.0 / 2.0) {
      compGainDb = 0.0;
    } else if (state.compEnvelope > -18.0 + 4.0 / 2.0) {
      compGainDb = -18.0 + (state.compEnvelope - -18.0) / state.compressionRatio - state.compEnvelope;
    } else {
      let x = state.compEnvelope - (-18.0 - 4.0 / 2.0);
      compGainDb = (1.0 / state.compressionRatio - 1.0) * x * x / (2.0 * 4.0);
    }
    let compressed = normalized * dbToLinear(compGainDb + 4.0);
    let ceilingLinear = dbToLinear(-0.5);
    let peak = Math.abs(compressed);
    if (peak > ceilingLinear) {
      let targetAtten = ceilingLinear / peak;
      if (targetAtten < state.limEnvelope) {
        state.limEnvelope = targetAtten;
      } else {
        state.limEnvelope = state.limEnvelope + state.limRelease * (1.0 - state.limEnvelope);
      }
    } else {
      state.limEnvelope = state.limEnvelope + state.limRelease * (1.0 - state.limEnvelope);
    }
    let limited = compressed * state.limEnvelope;
    output[i] = limited;
  });
}

function handleMessage(state, data) {
  
}

export {
  AudioWorkletProcessor,
  MessagePort,
  makeState,
  dbToLinear,
  linearToDb,
  clamp,
  processChannel,
  handleMessage,
}
/* No side effect */
